#!/bin/bash

# Some sanity checks
if [[ $$ -ne 1 ]]; then
	echo >&2 "This script is an init. Run it in a VM or as an initramfs"
	exit 1
fi

# reboot in case of termination
function initExit { echo b >| /proc/sysrq-trigger; }
trap initExit EXIT


typeset MYSELF="$(realpath $0)"
typeset MYPATH="${MYSELF%/*}"

set -o nounset -o noclobber
export LC_ALL=C
export PATH="/bin:/sbin:/usr/bin:/usr/sbin:$PATH"
export PS4=' (${BASH_SOURCE##*/}:$LINENO ${FUNCNAME[0]:-main})  '



function logDebug   { echo >&2 "[DBG] $@"; }
function logInfo    { echo >&2 "[INF] $@"; }
function logWarning { echo >&2 "[WRN] $@"; }
function logError   { echo >&2 "[ERR] $@"; }

function getVal {
	typeset key="$1"

	typeset tuple
	for tuple in $(< /proc/cmdline); do
		# Simple bool
		[[ "$tuple" == "$key" ]] && return 0
		# With value
		if [[ "${tuple%%=*}" == "$key" ]]; then
			echo "${tuple#*=}"
			return 0
		fi
	done

	return 1
}

# #############################################################################
#
# Minimal system setup
#
# #############################################################################
mount -t proc  none /proc
mount -t sysfs none /sys
mount -t tmpfs -o size=1g tmpfs /mnt/ramdisk

# Debug
getVal init.debug && set -x


# Setup network (just "eth*" no udev to rename)
typeset -A nicName= nicAddress= nicDuplex=
for nicPath in /sys/class/net/*; do

	# Skip virtual NICs
	[[ -e "$nicPath/device" ]] || continue

	typeset nicName="${nicPath##*/}"
	typeset nicId="$(<$nicPath/ifindex)"

	ip link set "$nicName" up

	nicName[$nicId]="$nicName"
	nicAddress[$nicId]="$(<"$nicPath/address")"
	nicDuplex[$nicId]="$(<"$nicPath/carrier")"
done

# #############################################################################
#
# Some information
#
# #############################################################################

typeset cpuInfo="$(</proc/cpuinfo)"
typeset cpuCnt="${cpuInfo##*processor}" ; cpuCnt="${cpuCnt%%$'\n'*}"; cpuCnt="${cpuCnt#*: }"
typeset cpuMod="${cpuInfo##*model name}"; cpuMod="${cpuMod%%$'\n'*}"; cpuMod="${cpuMod#*: }"
typeset ramInfo="$(</proc/meminfo)"
typeset ramTot="${ramInfo##*MemTotal:}";  ramTot="${ramTot%% kB*}"; ramTot="${ramTot##* }"

logInfo "# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"
logInfo "#                     Minimal initrd init"
logInfo "# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"
logInfo "# cmdline: $(</proc/cmdline)"
logInfo "# cpu: $((1 + $cpuCnt)) * $cpuMod"
logInfo "# ram: $ramTot"
# Skip id=0 (loopback)
for ((i=1; i<254; i+=1 )); do
	if (set +u; [[ -n "${nicName[$i]}" ]] ); then
		logInfo "# nic: id:$i name:${nicName[$i]} addr:${nicAddress[$i]} Duplex:${nicDuplex[$i]}"
	fi
done


typeset dmiPath="/sys/class/dmi/id"
if [[ -d "$dmiPath" ]]; then
	logInfo "# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"
	for dmiType in chassis product board; do
		typeset serialPath="$dmiPath/${dmiType}_serial"  vendorPath="$dmiPath/${dmiType}_vendor"
		typeset serial= vendor=
		[[ -r "$serialPath" ]] && serial="$(<$serialPath)"
		[[ -r "$vendorPath" ]] && vendor="$(<$vendorPath)"
		logInfo " ${dmiType^} serial: $serial    vendor: $vendor"
	done
else
	# try dmidecode
	#dmidecode 
	:
fi


logInfo "# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"



#cat >| "/stress/prime.ini" <<-EOT
#		TortureThreads=    ; Default is to detect automatically.
#		MinTortureFFT=8    ; In K
#		MaxTortureFFT=4096 ; In K
#		TortureMem=8       ; In MiB. Value is per thread.
#		TortureTime=15     ; In minutes
#EOT

#echo "===== Running stress test mprime"
#/stress/mprime -t

# If we need to reexec into something else
typeset initExec="$(getVal "init.exec")"
if [[ -n "$initExec" ]]; then
	logInfo "Executing '$initExec' from bootparam"
	if [[ -x "$initExec" ]]; then
		exec $initExec
	else
		logError "Not executable, Fallback to /bin/bash"
		exec /bin/bash
	fi
fi


# Try to use our scripts in lexicographical order
for file in /init.d/*; do
	# Execute script
	if [[ -x "$file" ]]; then
		"$file"
	fi
done

# #############################################################################
#
# Cleanup
#
# #############################################################################

sync

# Umount all blockdevices
typeset -a mntToUmount=()
while read blk mnt type junk; do
	if [[ "${blk:0:1}" == "/" ]]; then
		mntToUmount+=("$mnt")
	fi
done < /proc/mounts

typeset -i i="${#mntToUmount[@]}"
while [[ $i -gt 0 ]]; do
	typeset mnt="$mntToUmount[$(($i-1))]"
	logInfo "Umounting '$mnt'"
	umount "$mnt"
	if [[ $? -ne 0 ]]; then
		logError "Error during umount of '$mnt'."
	fi
	i+=-1
done



logInfo "Init ended. Will reboot from sysrq"


